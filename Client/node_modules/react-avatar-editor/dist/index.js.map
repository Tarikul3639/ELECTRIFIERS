{"version":3,"sources":["../src/index.ts","../src/utils/loadImageURL.ts","../src/utils/loadImageFile.ts","../src/utils/isPassiveSupported.ts","../src/utils/isTouchDevice.ts","../src/utils/isFileAPISupported.ts"],"sourcesContent":["import React, {\n  type TouchEventHandler,\n  type CSSProperties,\n  type MouseEventHandler,\n} from 'react'\n\nimport { loadImageURL } from './utils/loadImageURL'\nimport { loadImageFile } from './utils/loadImageFile'\nimport { isPassiveSupported } from './utils/isPassiveSupported'\nimport { isTouchDevice } from './utils/isTouchDevice'\nimport { isFileAPISupported } from './utils/isFileAPISupported'\n\n// Draws a rounded rectangle on a 2D context.\nconst drawRoundedRect = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  borderRadius: number,\n) => {\n  if (borderRadius === 0) {\n    context.rect(x, y, width, height)\n  } else {\n    const widthMinusRad = width - borderRadius\n    const heightMinusRad = height - borderRadius\n    context.translate(x, y)\n    context.arc(\n      borderRadius,\n      borderRadius,\n      borderRadius,\n      Math.PI,\n      Math.PI * 1.5,\n    )\n    context.lineTo(widthMinusRad, 0)\n    context.arc(\n      widthMinusRad,\n      borderRadius,\n      borderRadius,\n      Math.PI * 1.5,\n      Math.PI * 2,\n    )\n    context.lineTo(width, heightMinusRad)\n    context.arc(\n      widthMinusRad,\n      heightMinusRad,\n      borderRadius,\n      Math.PI * 2,\n      Math.PI * 0.5,\n    )\n    context.lineTo(borderRadius, height)\n    context.arc(\n      borderRadius,\n      heightMinusRad,\n      borderRadius,\n      Math.PI * 0.5,\n      Math.PI,\n    )\n    context.closePath()\n    context.translate(-x, -y)\n  }\n}\n\n// Draws a \"Rule of Three\" grid on the canvas.\nconst drawGrid = (\n  context: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  gridColor: string,\n) => {\n  context.fillStyle = gridColor\n  const thirdsX = width / 3\n  const thirdsY = height / 3\n\n  // vertical bars\n  context.fillRect(x, y, 1, height)\n  context.fillRect(thirdsX + x, y, 1, height)\n  context.fillRect(thirdsX * 2 + x, y, 1, height)\n  context.fillRect(thirdsX * 3 + x, y, 1, height)\n  context.fillRect(thirdsX * 4 + x, y, 1, height)\n\n  // horizontal bars\n  context.fillRect(x, y, width, 1)\n  context.fillRect(x, thirdsY + y, width, 1)\n  context.fillRect(x, thirdsY * 2 + y, width, 1)\n  context.fillRect(x, thirdsY * 3 + y, width, 1)\n  context.fillRect(x, thirdsY * 4 + y, width, 1)\n}\n\nconst defaultEmptyImage = {\n  x: 0.5,\n  y: 0.5,\n}\n\ntype BorderType = [number, number] | number\n\ninterface ImageState {\n  x: number\n  y: number\n  width?: number\n  height?: number\n  resource?: HTMLImageElement\n}\n\nexport interface Props {\n  width: number\n  height: number\n  style?: CSSProperties\n  image?: string | File\n  border?: BorderType\n  position?: Position\n  scale?: number\n  rotate?: number\n  borderRadius?: number\n  crossOrigin?: '' | 'anonymous' | 'use-credentials'\n  onLoadFailure?: () => void\n  onLoadSuccess?: (image: ImageState) => void\n  onImageReady?: () => void\n  onImageChange?: () => void\n  onMouseUp?: () => void\n  onMouseMove?: (e: TouchEvent | MouseEvent) => void\n  onPositionChange?: (position: Position) => void\n  color?: [number, number, number, number?]\n  backgroundColor?: string\n  disableBoundaryChecks?: boolean\n  disableHiDPIScaling?: boolean\n  disableCanvasRotation?: boolean\n  borderColor?: [number, number, number, number?]\n}\n\nexport interface Position {\n  x: number\n  y: number\n}\n\ninterface State {\n  drag: boolean\n  mx?: number\n  my?: number\n  image: ImageState\n}\n\ntype PropsWithDefaults = typeof AvatarEditor.defaultProps &\n  Omit<Props, keyof typeof AvatarEditor.defaultProps>\n\nclass AvatarEditor extends React.Component<PropsWithDefaults, State> {\n  private canvas = React.createRef<HTMLCanvasElement>()\n  private pixelRatio =\n    typeof window !== 'undefined' && window.devicePixelRatio\n      ? window.devicePixelRatio\n      : 1\n\n  static defaultProps = {\n    scale: 1,\n    rotate: 0,\n    border: 25,\n    borderRadius: 0,\n    width: 200,\n    height: 200,\n    color: [0, 0, 0, 0.5],\n    showGrid: false,\n    gridColor: '#666',\n    disableBoundaryChecks: false,\n    disableHiDPIScaling: false,\n    disableCanvasRotation: true,\n  }\n\n  state: State = {\n    drag: false,\n    my: undefined,\n    mx: undefined,\n    image: defaultEmptyImage,\n  }\n\n  componentDidMount() {\n    // scaling by the devicePixelRatio can impact performance on mobile as it creates a very large canvas.\n    // This is an override to increase performance.\n    if (this.props.disableHiDPIScaling) {\n      this.pixelRatio = 1\n    }\n    const context = this.getContext()\n\n    if (this.props.image) {\n      this.loadImage(this.props.image)\n    }\n    this.paint(context)\n\n    const options = isPassiveSupported() ? { passive: false } : false\n    document.addEventListener('mousemove', this.handleMouseMove, options)\n    document.addEventListener('mouseup', this.handleMouseUp, options)\n\n    if (isTouchDevice) {\n      document.addEventListener('touchmove', this.handleMouseMove, options)\n      document.addEventListener('touchend', this.handleMouseUp, options)\n    }\n  }\n\n  componentDidUpdate(prevProps: PropsWithDefaults, prevState: State) {\n    if (\n      this.props.image &&\n      (this.props.image !== prevProps.image ||\n        this.props.width !== prevProps.width ||\n        this.props.height !== prevProps.height ||\n        this.props.backgroundColor !== prevProps.backgroundColor)\n    ) {\n      this.loadImage(this.props.image)\n    } else if (!this.props.image && prevState.image !== defaultEmptyImage) {\n      this.clearImage()\n    }\n\n    const context = this.getContext()\n    context.clearRect(0, 0, this.getCanvas().width, this.getCanvas().height)\n    this.paint(context)\n    this.paintImage(context, this.state.image, this.props.border)\n\n    if (\n      prevProps.image !== this.props.image ||\n      prevProps.width !== this.props.width ||\n      prevProps.height !== this.props.height ||\n      prevProps.position !== this.props.position ||\n      prevProps.scale !== this.props.scale ||\n      prevProps.rotate !== this.props.rotate ||\n      prevState.my !== this.state.my ||\n      prevState.mx !== this.state.mx ||\n      prevState.image.x !== this.state.image.x ||\n      prevState.image.y !== this.state.image.y\n    ) {\n      this.props.onImageChange?.()\n    }\n  }\n\n  private getCanvas(): HTMLCanvasElement {\n    if (!this.canvas.current) {\n      throw new Error(\n        'No canvas found, please report this to: https://github.com/mosch/react-avatar-editor/issues',\n      )\n    }\n\n    return this.canvas.current\n  }\n\n  private getContext() {\n    const context = this.getCanvas().getContext('2d')\n    if (!context) {\n      throw new Error(\n        'No context found, please report this to: https://github.com/mosch/react-avatar-editor/issues',\n      )\n    }\n\n    return context\n  }\n\n  componentWillUnmount() {\n    document.removeEventListener('mousemove', this.handleMouseMove, false)\n    document.removeEventListener('mouseup', this.handleMouseUp, false)\n\n    if (isTouchDevice) {\n      document.removeEventListener('touchmove', this.handleMouseMove, false)\n      document.removeEventListener('touchend', this.handleMouseUp, false)\n    }\n  }\n\n  isVertical() {\n    return !this.props.disableCanvasRotation && this.props.rotate % 180 !== 0\n  }\n\n  getBorders(border = this.props.border) {\n    return Array.isArray(border) ? border : [border, border]\n  }\n\n  getDimensions() {\n    const { width, height, rotate, border } = this.props\n\n    const canvas = { width: 0, height: 0 }\n\n    const [borderX, borderY] = this.getBorders(border)\n\n    if (this.isVertical()) {\n      canvas.width = height\n      canvas.height = width\n    } else {\n      canvas.width = width\n      canvas.height = height\n    }\n\n    canvas.width += borderX * 2\n    canvas.height += borderY * 2\n\n    return {\n      canvas,\n      rotate,\n      width,\n      height,\n      border,\n    }\n  }\n\n  getImage() {\n    // get relative coordinates (0 to 1)\n    const cropRect = this.getCroppingRect()\n    const image = this.state.image\n\n    if (!image.resource) {\n      throw new Error(\n        'No image resource available, please report this to: https://github.com/mosch/react-avatar-editor/issues',\n      )\n    }\n\n    // get actual pixel coordinates\n    cropRect.x *= image.resource.width\n    cropRect.y *= image.resource.height\n    cropRect.width *= image.resource.width\n    cropRect.height *= image.resource.height\n\n    // create a canvas with the correct dimensions\n    const canvas = document.createElement('canvas')\n\n    if (this.isVertical()) {\n      canvas.width = cropRect.height\n      canvas.height = cropRect.width\n    } else {\n      canvas.width = cropRect.width\n      canvas.height = cropRect.height\n    }\n\n    // draw the full-size image at the correct position,\n    // the image gets truncated to the size of the canvas.\n    const context = this.getContext()\n\n    context.translate(canvas.width / 2, canvas.height / 2)\n    context.rotate((this.props.rotate * Math.PI) / 180)\n    context.translate(-(canvas.width / 2), -(canvas.height / 2))\n\n    if (this.isVertical()) {\n      context.translate(\n        (canvas.width - canvas.height) / 2,\n        (canvas.height - canvas.width) / 2,\n      )\n    }\n\n    if (this.props.backgroundColor) {\n      context.fillStyle = this.props.backgroundColor\n      context.fillRect(0, 0, canvas.width, canvas.height)\n    }\n\n    context.drawImage(image.resource, -cropRect.x, -cropRect.y)\n\n    return canvas\n  }\n\n  /**\n   * Get the image scaled to original canvas size.\n   * This was default in 4.x and is now kept as a legacy method.\n   */\n  getImageScaledToCanvas() {\n    const { width, height } = this.getDimensions()\n\n    const canvas = document.createElement('canvas')\n\n    if (this.isVertical()) {\n      canvas.width = height\n      canvas.height = width\n    } else {\n      canvas.width = width\n      canvas.height = height\n    }\n\n    // don't paint a border here, as it is the resulting image\n    this.paintImage(canvas.getContext('2d')!, this.state.image, 0, 1)\n\n    return canvas\n  }\n\n  getXScale() {\n    if (!this.state.image.width || !this.state.image.height)\n      throw new Error('Image dimension is unknown.')\n\n    const canvasAspect = this.props.width / this.props.height\n    const imageAspect = this.state.image.width / this.state.image.height\n\n    return Math.min(1, canvasAspect / imageAspect)\n  }\n\n  getYScale() {\n    if (!this.state.image.width || !this.state.image.height)\n      throw new Error('Image dimension is unknown.')\n\n    const canvasAspect = this.props.height / this.props.width\n    const imageAspect = this.state.image.height / this.state.image.width\n\n    return Math.min(1, canvasAspect / imageAspect)\n  }\n\n  getCroppingRect() {\n    const position = this.props.position || {\n      x: this.state.image.x,\n      y: this.state.image.y,\n    }\n    const width = (1 / this.props.scale) * this.getXScale()\n    const height = (1 / this.props.scale) * this.getYScale()\n\n    const croppingRect = {\n      x: position.x - width / 2,\n      y: position.y - height / 2,\n      width,\n      height,\n    }\n\n    let xMin = 0\n    let xMax = 1 - croppingRect.width\n    let yMin = 0\n    let yMax = 1 - croppingRect.height\n\n    // If the cropping rect is larger than the image, then we need to change\n    // our maxima & minima for x & y to allow the image to appear anywhere up\n    // to the very edge of the cropping rect.\n    const isLargerThanImage =\n      this.props.disableBoundaryChecks || width > 1 || height > 1\n\n    if (isLargerThanImage) {\n      xMin = -croppingRect.width\n      xMax = 1\n      yMin = -croppingRect.height\n      yMax = 1\n    }\n\n    return {\n      ...croppingRect,\n      x: Math.max(xMin, Math.min(croppingRect.x, xMax)),\n      y: Math.max(yMin, Math.min(croppingRect.y, yMax)),\n    }\n  }\n\n  async loadImage(file: File | string) {\n    if (isFileAPISupported && file instanceof File) {\n      try {\n        const image = await loadImageFile(file)\n        this.handleImageReady(image)\n      } catch (error) {\n        this.props.onLoadFailure?.()\n      }\n    } else if (typeof file === 'string') {\n      try {\n        const image = await loadImageURL(file, this.props.crossOrigin)\n        this.handleImageReady(image)\n      } catch {\n        this.props.onLoadFailure?.()\n      }\n    }\n  }\n\n  handleImageReady = (image: HTMLImageElement) => {\n    const imageState: ImageState = {\n      ...this.getInitialSize(image.width, image.height),\n      resource: image,\n      x: 0.5,\n      y: 0.5,\n    }\n\n    this.setState({ drag: false, image: imageState }, this.props.onImageReady)\n    this.props.onLoadSuccess?.(imageState)\n  }\n\n  getInitialSize(width: number, height: number) {\n    let newHeight: number\n    let newWidth: number\n\n    const dimensions = this.getDimensions()\n    const canvasRatio = dimensions.height / dimensions.width\n    const imageRatio = height / width\n\n    if (canvasRatio > imageRatio) {\n      newHeight = dimensions.height\n      newWidth = width * (newHeight / height)\n    } else {\n      newWidth = dimensions.width\n      newHeight = height * (newWidth / width)\n    }\n\n    return {\n      height: newHeight,\n      width: newWidth,\n    }\n  }\n\n  clearImage = () => {\n    const canvas = this.getCanvas()\n    const context = this.getContext()\n\n    context.clearRect(0, 0, canvas.width, canvas.height)\n    this.setState({ image: defaultEmptyImage })\n  }\n\n  paintImage(\n    context: CanvasRenderingContext2D,\n    image: ImageState,\n    border: number,\n    scaleFactor = this.pixelRatio,\n  ) {\n    if (!image.resource) return\n\n    const position = this.calculatePosition(image, border)\n\n    context.save()\n\n    context.translate(context.canvas.width / 2, context.canvas.height / 2)\n    context.rotate((this.props.rotate * Math.PI) / 180)\n    context.translate(-(context.canvas.width / 2), -(context.canvas.height / 2))\n\n    if (this.isVertical()) {\n      context.translate(\n        (context.canvas.width - context.canvas.height) / 2,\n        (context.canvas.height - context.canvas.width) / 2,\n      )\n    }\n\n    context.scale(scaleFactor, scaleFactor)\n\n    context.globalCompositeOperation = 'destination-over'\n    context.drawImage(\n      image.resource,\n      position.x,\n      position.y,\n      position.width,\n      position.height,\n    )\n\n    if (this.props.backgroundColor) {\n      context.fillStyle = this.props.backgroundColor\n      context.fillRect(0, 0, context.canvas.width, context.canvas.height)\n    }\n\n    context.restore()\n  }\n\n  calculatePosition(image = this.state.image, border?: number) {\n    const [borderX, borderY] = this.getBorders(border)\n\n    if (!image.width || !image.height) {\n      throw new Error('Image dimension is unknown.')\n    }\n\n    const croppingRect = this.getCroppingRect()\n\n    const width = image.width * this.props.scale\n    const height = image.height * this.props.scale\n\n    let x = -croppingRect.x * width\n    let y = -croppingRect.y * height\n\n    if (this.isVertical()) {\n      x += borderY\n      y += borderX\n    } else {\n      x += borderX\n      y += borderY\n    }\n\n    return { x, y, height, width }\n  }\n\n  paint(context: CanvasRenderingContext2D) {\n    context.save()\n    context.scale(this.pixelRatio, this.pixelRatio)\n    context.translate(0, 0)\n    context.fillStyle = 'rgba(' + this.props.color.slice(0, 4).join(',') + ')'\n\n    let borderRadius = this.props.borderRadius\n    const dimensions = this.getDimensions()\n    const [borderSizeX, borderSizeY] = this.getBorders(dimensions.border)\n    const height = dimensions.canvas.height\n    const width = dimensions.canvas.width\n\n    // clamp border radius between zero (perfect rectangle) and half the size without borders (perfect circle or \"pill\")\n    borderRadius = Math.max(borderRadius, 0)\n    borderRadius = Math.min(\n      borderRadius,\n      width / 2 - borderSizeX,\n      height / 2 - borderSizeY,\n    )\n\n    context.beginPath()\n    // inner rect, possibly rounded\n    drawRoundedRect(\n      context,\n      borderSizeX,\n      borderSizeY,\n      width - borderSizeX * 2,\n      height - borderSizeY * 2,\n      borderRadius,\n    )\n    context.rect(width, 0, -width, height) // outer rect, drawn \"counterclockwise\"\n    context.fill('evenodd')\n\n    // Draw 1px border around the mask only if borderColor is provided\n    if (this.props.borderColor) {\n      context.strokeStyle = 'rgba(' + this.props.borderColor.slice(0, 4).join(',') + ')'\n      context.lineWidth = 1\n      context.beginPath()\n      drawRoundedRect(\n        context,\n        borderSizeX + 0.5,\n        borderSizeY + 0.5,\n        width - borderSizeX * 2 - 1,\n        height - borderSizeY * 2 - 1,\n        borderRadius,\n      )\n      context.stroke()\n    }\n\n    if (this.props.showGrid) {\n      drawGrid(\n        context,\n        borderSizeX,\n        borderSizeY,\n        width - borderSizeX * 2,\n        height - borderSizeY * 2,\n        this.props.gridColor,\n      )\n    }\n    context.restore()\n  }\n\n  handleMouseDown: MouseEventHandler<HTMLCanvasElement> = (e) => {\n    // if e is a touch event, preventDefault keeps\n    // corresponding mouse events from also being fired\n    // later.\n    e.preventDefault()\n    this.setState({ drag: true, mx: undefined, my: undefined })\n  }\n\n  handleTouchStart: TouchEventHandler<HTMLCanvasElement> = (e) => {\n    // if e is a touch event, preventDefault keeps\n    // corresponding mouse events from also being fired\n    // later.\n    this.setState({ drag: true, mx: undefined, my: undefined })\n  }\n\n  handleMouseUp = () => {\n    if (this.state.drag) {\n      this.setState({ drag: false })\n      this.props.onMouseUp?.()\n    }\n  }\n\n  handleMouseMove = (e: MouseEvent | TouchEvent) => {\n    if (!this.state.drag) {\n      return\n    }\n\n    e.preventDefault() // stop scrolling on iOS Safari\n\n    const mousePositionX =\n      'targetTouches' in e ? e.targetTouches[0].pageX : e.clientX\n    const mousePositionY =\n      'targetTouches' in e ? e.targetTouches[0].pageY : e.clientY\n\n    this.setState({ mx: mousePositionX, my: mousePositionY })\n\n    let rotate = this.props.rotate\n\n    rotate %= 360\n    rotate = rotate < 0 ? rotate + 360 : rotate\n\n    if (\n      this.state.mx &&\n      this.state.my &&\n      this.state.image.width &&\n      this.state.image.height\n    ) {\n      const mx = this.state.mx - mousePositionX\n      const my = this.state.my - mousePositionY\n\n      const width = this.state.image.width * this.props.scale\n      const height = this.state.image.height * this.props.scale\n\n      let { x: lastX, y: lastY } = this.getCroppingRect()\n\n      lastX *= width\n      lastY *= height\n\n      // helpers to calculate vectors\n      const toRadians = (degree: number) => degree * (Math.PI / 180)\n      const cos = Math.cos(toRadians(rotate))\n      const sin = Math.sin(toRadians(rotate))\n\n      const x = lastX + mx * cos + my * sin\n      const y = lastY + -mx * sin + my * cos\n\n      const relativeWidth = (1 / this.props.scale) * this.getXScale()\n      const relativeHeight = (1 / this.props.scale) * this.getYScale()\n\n      const position = {\n        x: x / width + relativeWidth / 2,\n        y: y / height + relativeHeight / 2,\n      }\n\n      this.props.onPositionChange?.(position)\n\n      this.setState({ image: { ...this.state.image, ...position } })\n    }\n\n    this.props.onMouseMove?.(e)\n  }\n\n  render() {\n    const {\n      scale,\n      rotate,\n      image,\n      border,\n      borderRadius,\n      width,\n      height,\n      position,\n      color,\n      backgroundColor,\n      style,\n      crossOrigin,\n      onLoadFailure,\n      onLoadSuccess,\n      onImageReady,\n      onImageChange,\n      onMouseUp,\n      onMouseMove,\n      onPositionChange,\n      disableBoundaryChecks,\n      disableHiDPIScaling,\n      disableCanvasRotation,\n      showGrid,\n      gridColor,\n      borderColor,\n      ...rest\n    } = this.props\n\n    const dimensions = this.getDimensions()\n\n    const defaultStyle: CSSProperties = {\n      width: dimensions.canvas.width,\n      height: dimensions.canvas.height,\n      cursor: this.state.drag ? 'grabbing' : 'grab',\n      touchAction: 'none',\n    }\n\n    const attributes: JSX.IntrinsicElements['canvas'] = {\n      width: dimensions.canvas.width * this.pixelRatio,\n      height: dimensions.canvas.height * this.pixelRatio,\n      onMouseDown: this.handleMouseDown,\n      onTouchStart: this.handleTouchStart,\n      style: { ...defaultStyle, ...style },\n    }\n\n    return React.createElement('canvas', {\n      ...attributes,\n      ...rest,\n      ref: this.canvas,\n    })\n  }\n}\n\nexport default AvatarEditor\n","const isDataURL = (str: string) => {\n  const regex =\n    /^\\s*data:([a-z]+\\/[a-z]+(;[a-z-]+=[a-z-]+)?)?(;base64)?,[a-z0-9!$&',()*+;=\\-._~:@/?%\\s]*\\s*$/i\n  return !!str.match(regex)\n}\n\nexport const loadImageURL = (imageURL: string, crossOrigin?: string) =>\n  new Promise<HTMLImageElement>((resolve, reject) => {\n    const image = new Image()\n    image.onload = () => resolve(image)\n    image.onerror = reject\n    if (!isDataURL(imageURL) && crossOrigin) {\n      image.crossOrigin = crossOrigin\n    }\n    image.src = imageURL\n  })\n","import { loadImageURL } from './loadImageURL'\n\nexport const loadImageFile = (file: File) =>\n  new Promise<HTMLImageElement>((resolve, reject) => {\n    const reader = new FileReader()\n    reader.onload = (e) => {\n      try {\n        if (!e?.target?.result) {\n          throw new Error('No image data')\n        }\n        const image = loadImageURL(e.target.result as string)\n        resolve(image)\n      } catch (e) {\n        reject(e)\n      }\n    }\n    reader.readAsDataURL(file)\n  })\n","// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\nexport const isPassiveSupported = () => {\n  let passiveSupported = false\n  try {\n    const options = Object.defineProperty({}, 'passive', {\n      get: function () {\n        passiveSupported = true\n      },\n    })\n\n    const handler = () => {}\n    window.addEventListener('test', handler, options)\n    window.removeEventListener('test', handler, options)\n  } catch (err) {\n    passiveSupported = false\n  }\n  return passiveSupported\n}\n","export const isTouchDevice =\n  typeof window !== 'undefined' &&\n  typeof navigator !== 'undefined' &&\n  ('ontouchstart' in window || navigator.maxTouchPoints > 0)\n","export const isFileAPISupported = typeof File !== 'undefined'\n"],"mappings":"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","names":["e","React"]}